# Nodejs http并发问题

## 场景假设
- 一件商品，定价100,每有一个人购买，商品价格就-1

## 存在问题
- 存在两个人拿到相同的价格

## 注意
```
在高并发的程序中, 一定不要使用共享全局变量的方法来存储某个一直被修改的值
这样可能本次修改后还未使用，就被下次的修改覆盖掉了
尤其是nodejs常使用的express,koa框架中，如果某个值在一次请求中会被多个中间件使用
千万不要全局变量来存储的方式, 可以把这个在多个中间件中使用的值放到 req, 或者 res 中
然后在中间件中传输 这样这个值就不会被下次请求污染了
```

## 解决方案

### 缓存使用redis
- 原子锁

### 缓存使用mysql
- mysql 锁
- 引擎类型    行锁     表锁      页锁
- MyISAM      X       √        X
- BDB         X       √        √
- InnoDB      √       √        X

- 表锁：开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低
- 行锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高
- 页锁：开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般

- 表锁更适用于以查询为主，只有少量按索引条件更新数据的应用；
- 行锁更适用于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用
- PS：由于BDB已经被InnoDB所取代，我们只讨论MyISAM表锁和InnoDB行锁的问题

- InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁。
- MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。
- 具体请看mysql 索引，引擎相关的数据

### 缓存使用mongoDB
- mongodb不支持事物
- 没有redis相关的原子锁
- 暂时在数据库方面不能提供支持
- 只能在代码方面做调整，但是nodejs锁的问题比价难解决，或者调整业务可以解决
